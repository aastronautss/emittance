<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Module: Emittance::Action
  
    &mdash; Documentation by YARD 0.9.12
  
</title>

  <link rel="stylesheet" href="../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "Emittance::Action";
  relpath = '../';
</script>


  <script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../_index.html">Index (A)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../Emittance.html" title="Emittance (module)">Emittance</a></span></span>
     &raquo; 
    <span class="title">Action</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Module: Emittance::Action
  
  
  
</h1>
<div class="box_info">
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>lib/emittance/action.rb</dd>
  </dl>
  
</div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    
<p>There are certain classes (ergo objects) that represent an action taken by
another object. This pattern goes like so:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Foo</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_assign'>assign</span>
    <span class='const'>Assignment</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='kw'>self</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_call'>call</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>Assignment</span>
  <span class='id identifier rubyid_attr_reader'>attr_reader</span> <span class='symbol'>:assignable</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_assignable'>assignable</span><span class='rparen'>)</span>
    <span class='ivar'>@assignable</span> <span class='op'>=</span> <span class='id identifier rubyid_assignable'>assignable</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_call'>call</span>
    <span class='id identifier rubyid_do_stuff'>do_stuff</span>
  <span class='kw'>end</span>

  <span class='comment'># ...
</span><span class='kw'>end</span>
</code></pre>

<p>This pattern is useful for maintaining the single responsibility principle,
delegating complex tasks to other objects even when (in this particular
case), it might be sensible for the <code>assign</code> message to be sent
to <code>Foo</code>. This has numerous benefits, including the ability for
actions like <code>Assignment</code> to take a duck type.</p>

<p>However, this can easily just become a proxy for the same antipattern it
was made to solve. We might wind up with a  <code>#call</code> method like
the following:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Assignment</span>
  <span class='comment'># ...
</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_call'>call</span>
    <span class='id identifier rubyid_do_stuff'>do_stuff</span>
    <span class='id identifier rubyid_do_stuff_to_another_object'>do_stuff_to_another_object</span>
    <span class='id identifier rubyid_do_stuff_to_something_else'>do_stuff_to_something_else</span>
    <span class='id identifier rubyid_do_stuff_to_yet_another_thing'>do_stuff_to_yet_another_thing</span>
  <span class='kw'>end</span>

  <span class='comment'># ...
</span><span class='kw'>end</span>
</code></pre>

<p><code>Assignment</code> is suddenly collaborating with a whole bunch of
objects! This isn&#39;t bad in itself, but it might cause some problems
further on down the road as we add more responsibilities to
<code>Assignment</code>. Do we really want all these things to happen every
time an <code>Assignment</code> happens? If not, assuming this pattern
we&#39;ll have to add a bunch of  control flow:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Assignment</span>
  <span class='comment'># ...
</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_call'>call</span>
    <span class='id identifier rubyid_do_stuff'>do_stuff</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_some_condition'>some_condition</span>
      <span class='id identifier rubyid_do_stuff_to_another_object'>do_stuff_to_another_object</span>

      <span class='kw'>if</span> <span class='id identifier rubyid_some_other_condition'>some_other_condition</span>
        <span class='id identifier rubyid_do_stuff_to_something_else'>do_stuff_to_something_else</span>
      <span class='kw'>else</span>
        <span class='id identifier rubyid_do_stuff_to_yet_another_thing'>do_stuff_to_yet_another_thing</span>
      <span class='kw'>end</span>
    <span class='kw'>elsif</span> <span class='id identifier rubyid_yet_another_condition'>yet_another_condition</span>
      <span class='id identifier rubyid_do_other_stuff_to_that_other_object'>do_other_stuff_to_that_other_object</span>
    <span class='kw'>else</span>
      <span class='id identifier rubyid_dont_actually_do_anything_but_notify_someone'>dont_actually_do_anything_but_notify_someone</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='comment'># ...
</span><span class='kw'>end</span>
</code></pre>

<p>This is obviously an extreme example (but not unheard of!), but it gets to
the core of what this module tries to  solve.
<code>Emittance::Action</code> helps facilitate the single responsibility
principle by emitting an event whenever we invoke <code>#call</code> on an
object like <code>Assignment</code>.</p>

<h2 id="label-Usage">Usage</h2>

<p>First, define a class and include this module:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Assignment</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="../Emittance.html" title="Emittance (module)">Emittance</a></span></span><span class='op'>::</span><span class='const'>Action</span>

  <span class='id identifier rubyid_attr_reader'>attr_reader</span> <span class='symbol'>:assignable</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_assignable'>assignable</span><span class='rparen'>)</span>
    <span class='ivar'>@assignable</span> <span class='op'>=</span> <span class='id identifier rubyid_assignable'>assignable</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Per the pattern explained above, instances of this class are
representations of an action being carried out. This  class should have a
very minimal interface (maybe, at most, some getter methods for its
instance variables so the handler can make decisions based on its state).</p>

<p>Next, we&#39;ll implement the <code>#call</code> instance method.
<code>Emittance::Action</code> will take care of the dirty work for us:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Assignment</span>
  <span class='comment'># ...
</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_call'>call</span>
    <span class='id identifier rubyid_do_one_and_i_mean_only_one_thing'>do_one_and_i_mean_only_one_thing</span>
  <span class='kw'>end</span>

  <span class='comment'># ...
</span><span class='kw'>end</span>
</code></pre>

<p>Again, this method should do a single thing. From here, your code should be
able to run without error! You might  notice, though, that a mysterious
class will have been defined after loading this file.</p>

<pre class="code ruby"><code class="ruby">defined? AssignmentHandler
=&gt; &quot;constant&quot;</code></pre>

<p>Next, we can open up this class to implement the event handler.
<code>Emittance</code> will look for a method called 
<code>#handle_call</code>, and invoke it whenever, in this example,
<tt>Assignment#call</tt> is called.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>AssignmentHandler</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_handle_call'>handle_call</span>
    <span class='id identifier rubyid_notify_someone'>notify_someone</span><span class='lparen'>(</span><span class='id identifier rubyid_action'>action</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='comment'># ...
</span><span class='kw'>end</span>
</code></pre>

<p>The “Action” object is stored as the instance variable <tt>@action</tt>, made
available with a getter class <code>#action</code>. This will allow us to
access its data and make decisions based on it.</p>

<p>Now, this seems like we&#39;re passing the buck of all that control flow to
yet another object, but this pattern has  several advantages. First, we can
disable <code>Emittance</code> at will, so if we ever want to shut
<code>Assignment</code> actions off from their listeners, that is always an
option to us. Second, to address the concern raised at the beginning of
this paragraph, this paradigm puts us into the mindset of spreading the
flow of our program out across multiple  action/handler pairs, allowing us
to think more clearly about what our code is doing.</p>

<p>One possible disadvantage of this pattern is that it suggests a one-to-one
pairing between events and handlers.</p>


  </div>
</div>
<div class="tags">
  

</div><h2>Defined Under Namespace</h2>
<p class="children">
  
    
  
    
      <strong class="classes">Classes:</strong> <span class='object_link'><a href="Action/NoHandlerMethodError.html" title="Emittance::Action::NoHandlerMethodError (class)">NoHandlerMethodError</a></span>
    
  
</p>

  <h2>Constant Summary</h2>
  <dl class="constants">
    
      <dt id="EMITTING_METHOD-constant" class="">EMITTING_METHOD =
        
      </dt>
      <dd><pre class="code"><span class='symbol'>:call</span></pre></dd>
    
      <dt id="HANDLER_METHOD_NAME-constant" class="">HANDLER_METHOD_NAME =
        
      </dt>
      <dd><pre class="code"><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>handle_</span><span class='embexpr_beg'>#{</span><span class='const'><span class='object_link'><a href="#EMITTING_METHOD-constant" title="Emittance::Action::EMITTING_METHOD (constant)">EMITTING_METHOD</a></span></span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_to_sym'>to_sym</span></pre></dd>
    
  </dl>









</div>

      <div id="footer">
  Generated on Tue Nov 28 23:46:39 2017 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.12 (ruby-2.4.2).
</div>

    </div>
  </body>
</html>